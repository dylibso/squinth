// THIS FILE WAS GENERATED BY `xtp-cpp-bindgen`. DO NOT EDIT.
#define EXTISM_CPP_IMPLEMENTATION
#include "pdk.gen.hpp"
#include <extism-pdk.hpp>
#include <jsoncons/json.hpp>

JSONCONS_N_MEMBER_NAME_TRAITS(pdk::WaveArgs, 6, (inputs, "inputs"),
                              (sample, "sample"), (freq_hz, "freq_hz"),
                              (phase, "phase"), (sampleRate, "sampleRate"),
                              (isLeftChannel, "isLeftChannel"))

namespace pdk {

namespace exports {

int32_t EXTISM_EXPORTED_FUNCTION(wave) {
  extism::log_debug("wave: getting JSON input");
  auto input_str = extism::input().string();
  if (!input_str.size()) {
    extism::error_set("0 length input cannot be json");
    return -1;
  }
  auto input = jsoncons::decode_json<WaveArgs>(std::move(input_str));
  extism::log_debug("wave: calling implementation function");
  auto result = impl::wave(std::move(input));
  if (!result) {
    extism::error_set("wave: failed");
    return -3;
  }
  auto &output = *result;
  // if (!extism::output<// TODO: find better solution>(output)) {
  //   extism::error_set("outputting failed");
  //   return -5;
  // }
  extism::log_debug("wave: returning");
  return 0;
}

int32_t EXTISM_EXPORTED_FUNCTION(batch_compute_wf) {
  std::string input_str = extism::input().string();
  const char *inputData = input_str.c_str();

  float sample_time;
  memcpy(&sample_time, inputData, sizeof(float));
  float freq_hz;
  memcpy(&freq_hz, inputData + 4, sizeof(float));
  float curr_phase;
  memcpy(&curr_phase, inputData + (2 * 4), sizeof(float));

  int32_t num_samples;
  std::memcpy(&num_samples, inputData + (3 * 4), sizeof(int32_t));

  float input_one;
  memcpy(&input_one, inputData + (4 * 4), sizeof(float));
  float input_two;
  memcpy(&input_two, inputData + (5 * 4), sizeof(float));
  float input_three;
  memcpy(&input_three, inputData + (6 * 4), sizeof(float));
  float input_four;
  memcpy(&input_four, inputData + (7 * 4), sizeof(float));

  int32_t is_left_channel_num;
  memcpy(&is_left_channel_num, inputData + (8 * 4), sizeof(int32_t));
  bool is_left_channel = is_left_channel_num > 0;

  int64_t sample;
  memcpy(&sample, inputData + (9 * 4), sizeof(int64_t));

  float sample_rate;
  memcpy(&sample_rate, inputData + (11 * 4), sizeof(float));

  std::vector<float> inputs = {input_one, input_two};

  std::vector<uint8_t> outputData(num_samples * 4);
  for (size_t sample_no = 0; sample_no < num_samples;
       sample_no = sample_no + 1) {
    float phase = fmod(curr_phase + freq_hz * sample_time * sample_no, 1.0);
    sample += 1;
    WaveArgs args = {
        inputs, sample, freq_hz, phase, sample_rate, is_left_channel_num > 0,
    };

    float sample_val = impl::wave(std::move(args)).value();

    memcpy(outputData.data() + (sample_no * sizeof(float)), &sample_val,
           sizeof(float));
  }

  extism::output(
      std::span<const uint8_t>(outputData.data(), num_samples * sizeof(float)));

  return 0;
}

} // namespace exports

namespace imports {} // namespace imports

} // namespace pdk
